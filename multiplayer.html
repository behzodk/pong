<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Classic Pong - Multiplayer</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      background: radial-gradient(circle at center, #F6B17A, #000 70%);
      position: relative;
      overflow: hidden;
      color: #ffffff;
    }
    body::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2N89+7dfwAH/wN+971w/gAAAABJRU5ErkJggg==");
      opacity: 0.05;
      pointer-events: none;
      z-index: 0;
    }
    #gameTitle {
      position: fixed;
      top: 15%;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      font-family: 'Press Start 2P', monospace;
      font-size: 24px;
      letter-spacing: 3px;
      background: linear-gradient(45deg, #FF1944, #FFEF00, #00F1FF, #FF1944);
      background-size: 400%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradientShift 4s infinite linear;
      text-shadow: 1px 1px 0 #000;
      z-index: 2;
    }
    @keyframes gradientShift {
      0% { background-position: 0%; }
      100% { background-position: 100%; }
    }
    #contentWrapper {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    #gameBoard {
      width: 800px;
      height: 400px;
      background-color: #0A0A2A;
      position: relative;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
      z-index: 1;
    }
    #gameBoard::after {
      content: "";
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: repeating-linear-gradient(
        180deg,
        transparent,
        transparent 2px,
        rgba(10,10,42,0.2) 2px,
        rgba(10,10,42,0.2) 4px
      );
      pointer-events: none;
    }
    #centerLine {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: 0;
      bottom: 0;
      width: 2px;
      background: repeating-linear-gradient(to bottom, #ffffff, #ffffff 10px, transparent 10px, transparent 20px);
      box-shadow: 0 0 8px rgba(255,255,255,0.5);
    }
    .paddle {
      position: absolute;
      width: 10px;
      height: 60px;
      background-color: #ffffff;
      box-shadow: 0 0 8px rgba(255,255,255,0.5);
    }
    #leftPaddle {
      left: 20px;
      top: calc(50% - 30px);
    }
    #rightPaddle {
      right: 20px;
      top: calc(50% - 30px);
    }
    #ball {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #ffffff;
      border-radius: 50%;
      box-shadow: 0 0 8px rgba(255,255,255,0.5);
      left: calc(50% - 5px);
      top: calc(50% - 5px);
    }
    #scoreBoard {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      justify-content: space-between;
      width: 200px;
      font-family: 'Press Start 2P', monospace;
      color: #ffffff;
      text-shadow: 0 0 8px rgba(255,255,255,0.5);
      z-index: 2;
    }
    #scoreBoard > div {
      font-size: 16px;
    }
    #lobbyOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.82);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 4;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    #lobbyOverlay.hidden {
      display: none;
    }
    #lobbyPanel {
      background: rgba(5, 5, 20, 0.9);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      padding: 30px;
      width: 420px;
      font-family: 'Press Start 2P', monospace;
      color: #fff;
      box-shadow: 0 10px 40px rgba(0,0,0,0.4);
    }
    #lobbyPanel h2 {
      margin-top: 0;
      font-size: 18px;
    }
    .lobby-hint {
      font-size: 10px;
      color: rgba(255,255,255,0.8);
      margin-bottom: 20px;
      line-height: 1.6;
    }
    .lobby-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-bottom: 20px;
    }
    .lobby-actions button,
    #copyLinkBtn {
      background: linear-gradient(90deg, #FF1944, #FFB347);
      color: #000;
      border: none;
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
      padding: 10px 14px;
      border-radius: 6px;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }
    .lobby-actions button:disabled,
    #copyLinkBtn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    #roomIdInput {
      flex: 1 1 120px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      color: #fff;
      padding: 10px;
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
      text-transform: uppercase;
    }
    #shareLinkContainer {
      border-top: 1px solid rgba(255,255,255,0.2);
      margin-top: 15px;
      padding-top: 15px;
      font-size: 10px;
    }
    #shareLinkContainer.hidden {
      display: none;
    }
    .share-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
      word-break: break-all;
    }
    #shareLink {
      color: #00F1FF;
      text-decoration: none;
      font-size: 10px;
      flex: 1;
      text-align: left;
    }
    #statusMessage {
      margin-top: 20px;
      font-size: 10px;
      min-height: 30px;
      line-height: 1.4;
    }
    #notLaptopMsg {
      color: #fff;
      font-size: 24px;
      text-align: center;
      margin-top: 40vh;
      font-family: sans-serif;
      z-index: 3;
      position: relative;
    }
    #winMessage {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      color: #fff;
      font-family: 'Press Start 2P', monospace;
      font-size: 32px;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="gameTitle">PING-PONG</div>
  <div id="contentWrapper">
    <div id="gameBoard">
      <div id="scoreBoard">
        <div id="leftScore">0</div>
        <div id="rightScore">0</div>
      </div>
      <div id="centerLine"></div>
      <div class="paddle" id="leftPaddle"></div>
      <div class="paddle" id="rightPaddle"></div>
      <div id="ball"></div>
    </div>
  </div>

  <div id="lobbyOverlay">
    <div id="lobbyPanel">
      <h2>Multiplayer Lobby</h2>
      <p class="lobby-hint">Each player can move with W/S or Arrow keys. Create a room, share the link, and wait for both players to connect.</p>
      <div class="lobby-actions">
        <button id="createRoomBtn">Create Room</button>
        <input id="roomIdInput" placeholder="Room ID" maxlength="8" autocomplete="off" />
        <button id="joinRoomBtn">Join Room</button>
      </div>
      <div id="shareLinkContainer" class="hidden">
        <p>Share this link with your opponent:</p>
        <div class="share-row">
          <a id="shareLink" href="#" target="_blank" rel="noopener"></a>
          <button id="copyLinkBtn">Copy</button>
        </div>
      </div>
      <div id="statusMessage">Connecting to multiplayer server...</div>
    </div>
  </div>

  <script>
    (function () {
      function isLaptop() {
        return !(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
      }

      if (!isLaptop()) {
        document.body.innerHTML = '<div id="notLaptopMsg">Game is only for laptops</div>';
        return;
      }

      const REMOTE_SOCKET_HOST = 'pong-tuzn.onrender.com';
      const DEFAULT_LOCAL_PORT = 10000;
      const lobbyOverlay = document.getElementById('lobbyOverlay');
      const createRoomBtn = document.getElementById('createRoomBtn');
      const joinRoomBtn = document.getElementById('joinRoomBtn');
      const roomIdInput = document.getElementById('roomIdInput');
      const shareLinkContainer = document.getElementById('shareLinkContainer');
      const shareLinkEl = document.getElementById('shareLink');
      const copyLinkBtn = document.getElementById('copyLinkBtn');
      const statusMessage = document.getElementById('statusMessage');

      const gameBoard = document.getElementById('gameBoard');
      const leftPaddle = document.getElementById('leftPaddle');
      const rightPaddle = document.getElementById('rightPaddle');
      const ball = document.getElementById('ball');
      const leftScoreEl = document.getElementById('leftScore');
      const rightScoreEl = document.getElementById('rightScore');

      const urlParams = new URLSearchParams(window.location.search);
      const roomFromUrl = urlParams.get('room');
      const serverParam = (urlParams.get('server') || '').toLowerCase();
      const forceLocalServer = serverParam === 'local';
      if (roomFromUrl) {
        roomIdInput.value = roomFromUrl.toUpperCase();
      }

      let socket = null;
      let socketReady = false;
      let roomId = roomFromUrl ? roomFromUrl.toUpperCase() : null;
      let playerRole = null;
      let gameInitialized = false;
      let gameStarted = false;
      let matchActive = false;

      const keys = {};
      let controlsBound = false;
      let currentInput = { up: false, down: false };
      let inputLoopId = null;

      const ballSize = 10;
      const BOARD_WIDTH = 800;
      const BOARD_HEIGHT = 400;
      const PADDLE_WIDTH = 10;
      const PADDLE_HEIGHT = 60;
      const PADDLE_MARGIN = 20;
      const initialSpeedX = 280;
      const initialSpeedY = 200;
      const accelerationFactor = 1.04;
      const paddleSpeedPerSec = 420;
      const maxScore = 11;
      const paddleLagPadding = 12; // compensate for network delay on remote paddle collisions
      const NETWORK_TICK_RATE = 60;
      const STATE_TICK_MS = 1000 / NETWORK_TICK_RATE;
      const PADDLE_TICK_MS = STATE_TICK_MS;
      const SIM_TICK_RATE = 120;
      const SIM_DT_MS = 1000 / SIM_TICK_RATE;
      const SIM_DT_S = SIM_DT_MS / 1000;
      const INPUT_DELAY_FRAMES = 2;
      const MAX_ROLLBACK_FRAMES = 12;
      const SNAPSHOT_BASE_BUFFER_MS = 200;
      const MAX_PREDICTION_MS = 80;
      const FRAME_TIME_MS = 1000 / 60;
      const OPPONENT_LERP_FACTOR = 0.2;
      const MAX_SNAPSHOTS = 20;
      const PING_INTERVAL_MS = 1000;
      const METRICS_WINDOW = 20;
      const MAX_HISTORY_FRAMES = MAX_ROLLBACK_FRAMES * 4;
      const CORRECTION_THRESHOLD = 4;
      const CORRECTION_THRESHOLD_BALL = 6;

      let leftScore = 0;
      let rightScore = 0;
      let gameOver = false;
      let winnerLabel = '';
      let ballX = gameBoard.clientWidth / 2 - ballSize / 2;
      let ballY = gameBoard.clientHeight / 2 - ballSize / 2;
      let renderBallX = ballX;
      let renderBallY = ballY;
      let ballVelocityX = initialSpeedX;
      let ballVelocityY = initialSpeedY;
      let leftPaddleY = gameBoard.clientHeight / 2 - leftPaddle.offsetHeight / 2;
      let rightPaddleY = gameBoard.clientHeight / 2 - rightPaddle.offsetHeight / 2;
      let renderLeftPaddleY = leftPaddleY;
      let renderRightPaddleY = rightPaddleY;
      let lastLocalInput = { up: false, down: false };
      let simAccumulator = 0;
      let lastUpdateTime = null;
      let dynamicSnapshotDelay = SNAPSHOT_BASE_BUFFER_MS;
      let pingTimer = null;
      let lastPingSentAt = 0;
      const pendingPings = new Map();
      let pingCounter = 0;
      const rttSamples = [];
      const jitterSamples = [];
      let rttEstimate = 120;
      let jitterEstimate = 10;
      let lastRttValue = null;

      const stateSnapshots = [];
      let latestSnapshot = null;
      const simState = createSimState();
      let simFrame = 0;
      const stateHistory = new Map();
      const historyOrder = [];
      const localInputBuffer = new Map();
      const localInputOrder = [];
      const remoteInputBuffer = { left: new Map(), right: new Map() };
      const remoteInputOrder = { left: [], right: [] };
      const lastRemoteInput = {
        left: { up: false, down: false },
        right: { up: false, down: false },
      };
      let correctionsApplied = 0;
      const MAX_BUFFERED_INPUTS = MAX_ROLLBACK_FRAMES * 6;

      setLobbyControlsDisabled(true);

      roomIdInput.addEventListener('input', () => {
        roomIdInput.value = roomIdInput.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
      });

      createRoomBtn.addEventListener('click', () => {
        if (!socketReady) return;
        shareLinkContainer.classList.add('hidden');
        setStatus('Creating room...');
        socket.send(JSON.stringify({ type: 'createRoom' }));
        setLobbyControlsDisabled(true);
      });

      joinRoomBtn.addEventListener('click', () => {
        if (!socketReady) return;
        const requestedRoom = roomIdInput.value.trim().toUpperCase();
        if (!requestedRoom) {
          setStatus('Enter a room ID before joining.');
          return;
        }
        socket.send(JSON.stringify({ type: 'joinRoom', roomId: requestedRoom }));
        setStatus(`Joining room ${requestedRoom}...`);
        setLobbyControlsDisabled(true);
      });

      copyLinkBtn.addEventListener('click', () => {
        const link = shareLinkEl.textContent;
        if (!link) return;
        if (navigator.clipboard && window.isSecureContext) {
          navigator.clipboard.writeText(link).then(showCopiedState).catch(() => { showCopiedState(false); });
        } else {
          const tempInput = document.createElement('input');
          tempInput.value = link;
          document.body.appendChild(tempInput);
          tempInput.select();
          try {
            document.execCommand('copy');
            showCopiedState();
          } catch (error) {
            showCopiedState(false);
          }
          document.body.removeChild(tempInput);
        }
      });

      function showCopiedState(success = true) {
        if (!success) {
          setStatus('Unable to copy automatically; copy the link manually.');
          return;
        }
        const previous = copyLinkBtn.textContent;
        copyLinkBtn.textContent = 'Copied!';
        copyLinkBtn.disabled = true;
        setTimeout(() => {
          copyLinkBtn.textContent = previous;
          copyLinkBtn.disabled = false;
        }, 1200);
      }

      function createSimState(snapshot = null) {
        const baseBallX = gameBoard.clientWidth / 2 - ballSize / 2;
        const baseBallY = gameBoard.clientHeight / 2 - ballSize / 2;
        const basePaddleY = gameBoard.clientHeight / 2 - leftPaddle.offsetHeight / 2;
        const source = snapshot || {};
        return {
          frame: source.frame || 0,
          ballX: typeof source.ballX === 'number' ? source.ballX : baseBallX,
          ballY: typeof source.ballY === 'number' ? source.ballY : baseBallY,
          ballVX: typeof source.ballVX === 'number' ? source.ballVX : initialSpeedX,
          ballVY: typeof source.ballVY === 'number' ? source.ballVY : initialSpeedY,
          leftY: typeof source.leftPaddleY === 'number' ? source.leftPaddleY : basePaddleY,
          rightY: typeof source.rightPaddleY === 'number' ? source.rightPaddleY : basePaddleY,
          leftScore: typeof source.leftScore === 'number' ? source.leftScore : 0,
          rightScore: typeof source.rightScore === 'number' ? source.rightScore : 0,
          gameOver: Boolean(source.gameOver),
          winner: source.winner || null,
        };
      }

      function cloneSimState(state) {
        return {
          frame: state.frame,
          ballX: state.ballX,
          ballY: state.ballY,
          ballVX: state.ballVX,
          ballVY: state.ballVY,
          leftY: state.leftY,
          rightY: state.rightY,
          leftScore: state.leftScore,
          rightScore: state.rightScore,
          gameOver: state.gameOver,
          winner: state.winner,
        };
      }

      function syncViewState() {
        leftPaddleY = simState.leftY;
        rightPaddleY = simState.rightY;
        renderLeftPaddleY = leftPaddleY;
        renderRightPaddleY = rightPaddleY;
        ballX = simState.ballX;
        ballY = simState.ballY;
        ballVelocityX = simState.ballVX;
        ballVelocityY = simState.ballVY;
        renderBallX = ballX;
        renderBallY = ballY;
        leftScore = simState.leftScore;
        rightScore = simState.rightScore;
        leftScoreEl.textContent = leftScore;
        rightScoreEl.textContent = rightScore;
        opponentTargets.left = leftPaddleY;
        opponentTargets.right = rightPaddleY;
      }

      function storeStateHistory(state) {
        const copy = cloneSimState(state);
        stateHistory.set(copy.frame, copy);
        historyOrder.push(copy.frame);
        while (historyOrder.length > MAX_HISTORY_FRAMES) {
          const oldest = historyOrder.shift();
          stateHistory.delete(oldest);
        }
      }

      function recordLocalInput(frame, input) {
        lastLocalInput = { ...input };
        localInputBuffer.set(frame, { ...input });
        localInputOrder.push(frame);
        while (localInputOrder.length > MAX_BUFFERED_INPUTS) {
          const oldest = localInputOrder.shift();
          localInputBuffer.delete(oldest);
        }
      }

      function recordRemoteInput(role, frame, input = {}) {
        if (!remoteInputBuffer[role]) return;
        const packet = {
          up: Boolean(input.up),
          down: Boolean(input.down),
        };
        remoteInputBuffer[role].set(frame, packet);
        remoteInputOrder[role].push(frame);
        while (remoteInputOrder[role].length > MAX_BUFFERED_INPUTS) {
          const oldest = remoteInputOrder[role].shift();
          remoteInputBuffer[role].delete(oldest);
        }
        lastRemoteInput[role] = packet;
      }

      function inputToAxis(input) {
        if (!input) return 0;
        if (input.up && !input.down) return -1;
        if (input.down && !input.up) return 1;
        return 0;
      }

      function getInputForFrame(role, frame) {
        if (role === playerRole) {
          if (localInputBuffer.has(frame)) {
            lastLocalInput = localInputBuffer.get(frame);
          }
          return lastLocalInput;
        }
        const packet = remoteInputBuffer[role]?.get(frame);
        if (packet) {
          lastRemoteInput[role] = packet;
          return packet;
        }
        return lastRemoteInput[role];
      }

      function lookupInput(role, frame) {
        if (role === playerRole) {
          return localInputBuffer.get(frame) || lastLocalInput;
        }
        return remoteInputBuffer[role].get(frame) || lastRemoteInput[role];
      }

      function statesDiffer(localState, snapshot) {
        if (!localState || !snapshot) return true;
        if (Math.abs(localState.ballX - snapshot.ballX) > CORRECTION_THRESHOLD_BALL) return true;
        if (Math.abs(localState.ballY - snapshot.ballY) > CORRECTION_THRESHOLD_BALL) return true;
        if (Math.abs(localState.leftY - snapshot.leftPaddleY) > CORRECTION_THRESHOLD) return true;
        if (Math.abs(localState.rightY - snapshot.rightPaddleY) > CORRECTION_THRESHOLD) return true;
        if (localState.leftScore !== snapshot.leftScore) return true;
        if (localState.rightScore !== snapshot.rightScore) return true;
        return false;
      }

      function trimInputBuffers(frameThreshold) {
        while (localInputOrder.length && localInputOrder[0] < frameThreshold) {
          const oldest = localInputOrder.shift();
          localInputBuffer.delete(oldest);
        }
        ['left', 'right'].forEach((role) => {
          while (remoteInputOrder[role].length && remoteInputOrder[role][0] < frameThreshold) {
            const oldest = remoteInputOrder[role].shift();
            remoteInputBuffer[role].delete(oldest);
          }
        });
      }

      function resetSimulation(snapshot) {
        simAccumulator = 0;
        lastUpdateTime = null;
        localInputBuffer.clear();
        localInputOrder.length = 0;
        ['left', 'right'].forEach((role) => {
          remoteInputBuffer[role].clear();
          remoteInputOrder[role].length = 0;
          lastRemoteInput[role] = { up: false, down: false };
        });
        lastLocalInput = { up: false, down: false };
        const baseState = createSimState(snapshot);
        Object.assign(simState, baseState);
        simFrame = baseState.frame || 0;
        stateHistory.clear();
        historyOrder.length = 0;
        storeStateHistory(simState);
        if (snapshot) {
          recordRemoteInput('left', snapshot.leftInputFrame || snapshot.frame || 0, snapshot.leftInput);
          recordRemoteInput('right', snapshot.rightInputFrame || snapshot.frame || 0, snapshot.rightInput);
        }
        syncViewState();
      }

      function applySnapshotToSim(snapshot) {
        Object.assign(simState, createSimState(snapshot));
      }

      function runLocalSimulation() {
        if (!matchActive || gameOver) return;
        const now = performance.now();
        if (lastUpdateTime == null) {
          lastUpdateTime = now;
          return;
        }

        let delta = now - lastUpdateTime;
        if (delta > 200) delta = 200;
        lastUpdateTime = now;
        simAccumulator += delta;

        let advanced = false;
        while (simAccumulator >= SIM_DT_MS) {
          simAccumulator -= SIM_DT_MS;
          const targetFrame = simFrame + 1;
          const leftInput = getInputForFrame('left', targetFrame);
          const rightInput = getInputForFrame('right', targetFrame);
          stepSimulation(simState, leftInput, rightInput);
          storeStateHistory(simState);
          simFrame = targetFrame;
          advanced = true;
        }

        if (advanced) {
          trimInputBuffers(simFrame - MAX_ROLLBACK_FRAMES);
          syncViewState();
          runGuestSpeculativeCollisions();
          updateBallPosition();
        }
      }

      function stepSimulation(state, leftInput, rightInput) {
        if (!state) return;
        state.frame = (state.frame || 0) + 1;
        if (state.gameOver) return;

        const dt = SIM_DT_S;
        const paddleDelta = paddleSpeedPerSec * dt;

        const axisLeft = inputToAxis(leftInput);
        const axisRight = inputToAxis(rightInput);
        state.leftY += axisLeft * paddleDelta;
        state.rightY += axisRight * paddleDelta;

        const paddleLimit = BOARD_HEIGHT - PADDLE_HEIGHT;
        state.leftY = clamp(state.leftY, 0, paddleLimit);
        state.rightY = clamp(state.rightY, 0, paddleLimit);

        let nextBallX = state.ballX + state.ballVX * dt;
        let nextBallY = state.ballY + state.ballVY * dt;

        if (nextBallY <= 0) {
          nextBallY = 0;
          state.ballVY = Math.abs(state.ballVY);
        } else if (nextBallY + ballSize >= BOARD_HEIGHT) {
          nextBallY = BOARD_HEIGHT - ballSize;
          state.ballVY = -Math.abs(state.ballVY);
        }

        const rightPaddleX = BOARD_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH;
        if (
          state.ballVX > 0 &&
          nextBallX + ballSize >= rightPaddleX &&
          nextBallX <= rightPaddleX + PADDLE_WIDTH &&
          nextBallY + ballSize >= state.rightY &&
          nextBallY <= state.rightY + PADDLE_HEIGHT
        ) {
          nextBallX = rightPaddleX - ballSize;
          state.ballVX = -Math.abs(state.ballVX);
          reflectBallState(state, state.rightY);
        }

        const leftPaddleX = PADDLE_MARGIN;
        if (
          state.ballVX < 0 &&
          nextBallX <= leftPaddleX + PADDLE_WIDTH &&
          nextBallX + ballSize >= leftPaddleX &&
          nextBallY + ballSize >= state.leftY &&
          nextBallY <= state.leftY + PADDLE_HEIGHT
        ) {
          nextBallX = leftPaddleX + PADDLE_WIDTH;
          state.ballVX = Math.abs(state.ballVX);
          reflectBallState(state, state.leftY);
        }

        state.ballX = nextBallX;
        state.ballY = nextBallY;

        if (state.ballX < 0) {
          state.rightScore += 1;
          resetBallState(state, 'right');
        } else if (state.ballX + ballSize > BOARD_WIDTH) {
          state.leftScore += 1;
          resetBallState(state, 'left');
        }

        if (!state.gameOver && (state.leftScore >= maxScore || state.rightScore >= maxScore)) {
          state.gameOver = true;
          state.winner = state.leftScore > state.rightScore ? 'Left Player' : 'Right Player';
        }
      }

      function reflectBallState(state, paddleY) {
        const paddleCenter = paddleY + PADDLE_HEIGHT / 2;
        const ballCenter = state.ballY + ballSize / 2;
        const offset = (ballCenter - paddleCenter) / (PADDLE_HEIGHT / 2);
        const deflection = offset * 220;
        state.ballVY = clamp(state.ballVY * accelerationFactor + deflection, -500, 500);
        state.ballVX *= accelerationFactor;
      }

      function resetBallState(state, scorer) {
        state.ballX = BOARD_WIDTH / 2 - ballSize / 2;
        state.ballY = BOARD_HEIGHT / 2 - ballSize / 2;
        state.ballVX = initialSpeedX * (scorer === 'left' ? 1 : -1);
        state.ballVY = initialSpeedY * (Math.random() > 0.5 ? 1 : -1);
      }

      function setStatus(message) {
        statusMessage.textContent = message;
      }

      function setLobbyControlsDisabled(disabled) {
        createRoomBtn.disabled = disabled;
        joinRoomBtn.disabled = disabled;
        roomIdInput.disabled = disabled;
      }

      function updateUrlWithRoom(id) {
        try {
          const url = new URL(window.location.href);
          url.searchParams.set('room', id);
          window.history.replaceState({}, '', url);
        } catch (error) {
          // Ignore history errors (e.g., file protocol)
        }
      }

      function buildShareLink(id) {
        try {
          const shareUrl = new URL(window.location.href);
          shareUrl.searchParams.set('room', id);
          return shareUrl.toString();
        } catch (error) {
          return `?room=${id}`;
        }
      }

      function debugLog(...args) {
        console.log('[multiplayer]', ...args);
      }

      function resolveSocketUrl() {
        const { protocol, hostname, port } = window.location;
        const remoteUrl = `wss://${REMOTE_SOCKET_HOST}`;

        if (forceLocalServer) {
          const scheme = protocol === 'https:' ? 'wss://' : 'ws://';
          const targetHost = hostname || 'w';
          const targetPort = port || DEFAULT_LOCAL_PORT;
          debugLog('Server override: local');
          return `${scheme}${targetHost}:${targetPort}`;
        }

        debugLog('Using remote server');
        return remoteUrl;
      }

      function connectSocket() {
        const socketUrl = resolveSocketUrl();
        debugLog('Connecting to', socketUrl);
        setStatus(`Connecting to multiplayer server (${socketUrl})...`);
        socket = new WebSocket(socketUrl);

        socket.addEventListener('open', () => {
          socketReady = true;
          debugLog('WebSocket open', socket.readyState);
          setStatus('Connected. Create a room or join an existing one.');
          setLobbyControlsDisabled(false);
          startPingLoop();
          if (roomFromUrl) {
            socket.send(JSON.stringify({ type: 'joinRoom', roomId: roomFromUrl.toUpperCase() }));
            setStatus(`Attempting to join room ${roomFromUrl.toUpperCase()}...`);
            setLobbyControlsDisabled(true);
          }
        });

        socket.addEventListener('message', (event) => {
          debugLog('WebSocket message', event.data);
          let payload;
          try {
            payload = JSON.parse(event.data);
          } catch (error) {
            console.error('Invalid message from server', event.data);
            return;
          }
          handleServerMessage(payload);
        });

        socket.addEventListener('close', (event) => {
          socketReady = false;
          matchActive = false;
          gameStarted = false;
          stopInputLoop();
          stopPingLoop();
          debugLog('WebSocket close', event.code, event.reason);
          setStatus('Disconnected from server. Refresh the page to reconnect.');
          setLobbyControlsDisabled(true);
          lobbyOverlay.classList.remove('hidden');
        });

        socket.addEventListener('error', (event) => {
          debugLog('WebSocket error', event);
          setStatus('Connection error. Check the console for details and refresh the page.');
          stopPingLoop();
        });
      }

      function startPingLoop() {
        if (pingTimer || !socket) return;
        sendPing();
        pingTimer = window.setInterval(() => {
          sendPing();
        }, PING_INTERVAL_MS);
      }

      function stopPingLoop() {
        if (pingTimer) {
          window.clearInterval(pingTimer);
          pingTimer = null;
        }
        pendingPings.clear();
      }

      function sendPing() {
        if (!socketReady || !socket || socket.readyState !== WebSocket.OPEN) return;
        const id = ++pingCounter;
        pendingPings.set(id, performance.now());
        lastPingSentAt = Date.now();
        socket.send(JSON.stringify({ type: 'ping', id, clientTime: lastPingSentAt }));
      }

      function startInputLoop() {
        if (inputLoopId) return;
        inputLoopId = window.setInterval(() => {
        if (!socketReady || !roomId || !playerRole || !matchActive) return;
        if (!socket || socket.readyState !== WebSocket.OPEN) return;
        const targetFrame = simFrame + INPUT_DELAY_FRAMES;
        socket.send(JSON.stringify({
          type: 'input',
          roomId,
          frame: targetFrame,
          role: playerRole,
          up: Boolean(currentInput.up),
          down: Boolean(currentInput.down),
        }));
      }, PADDLE_TICK_MS);
      }

      function stopInputLoop() {
        if (!inputLoopId) return;
        window.clearInterval(inputLoopId);
        inputLoopId = null;
      }

      function handleServerMessage(message) {
        switch (message.type) {
          case 'roomCreated':
            roomId = message.roomId;
            playerRole = message.role;
            setStatus(`Room ${roomId} created. Waiting for your opponent...`);
            shareLinkContainer.classList.remove('hidden');
            const shareLink = buildShareLink(roomId);
            shareLinkEl.textContent = shareLink;
            shareLinkEl.href = shareLink;
            copyLinkBtn.disabled = false;
            updateUrlWithRoom(roomId);
            roomIdInput.value = roomId;
            break;
          case 'roomJoined':
            roomId = message.roomId;
            playerRole = message.role;
            setStatus('Joined room. Waiting for the server to start the match...');
            updateUrlWithRoom(roomId);
            roomIdInput.value = roomId;
            break;
          case 'playerJoined':
            setStatus('Opponent connected! Preparing the match...');
            break;
          case 'roomReady':
            setStatus('Both players are ready. Waiting for the server...');
            break;
          case 'matchStart':
            setStatus('Match starting!');
            beginMatch(message.state);
            break;
          case 'state':
            handleStateSnapshot(message.state);
            break;
          case 'pong':
            handlePong(message);
            break;
          case 'opponentLeft':
            handleOpponentLeft();
            break;
          case 'error':
            setStatus(message.message || 'Server error.');
            setLobbyControlsDisabled(false);
            break;
          default:
            console.warn('Unhandled server message', message);
        }
      }

      function handleOpponentLeft() {
        gameOver = true;
        matchActive = false;
        gameStarted = false;
        stopInputLoop();
        if (!document.getElementById('winMessage')) {
          setStatus('Opponent disconnected. Refresh to start a new match.');
          lobbyOverlay.classList.remove('hidden');
        }
      }

      function handlePong(message) {
        if (!message || typeof message.id !== 'number') return;
        const sentAt = pendingPings.get(message.id);
        if (!sentAt) return;
        pendingPings.delete(message.id);
        const rtt = performance.now() - sentAt;
        rttSamples.push(rtt);
        if (rttSamples.length > METRICS_WINDOW) rttSamples.shift();
        if (lastRttValue !== null) {
          const jitter = Math.abs(rtt - lastRttValue);
          jitterSamples.push(jitter);
          if (jitterSamples.length > METRICS_WINDOW) jitterSamples.shift();
        }
        lastRttValue = rtt;
        rttEstimate = averageSamples(rttSamples) || rttEstimate;
        jitterEstimate = averageSamples(jitterSamples) || jitterEstimate;
        updateDynamicSnapshotDelay();
      }

      function beginMatch(snapshot) {
        matchActive = true;
        gameOver = false;
        winnerLabel = '';
        resetSimulation(snapshot);
        lobbyOverlay.classList.add('hidden');
        syncViewState();
        if (!gameInitialized) {
          initializeGame();
        } else if (!gameStarted) {
          requestAnimationFrame(update);
        }
        gameStarted = true;
        startInputLoop();
      }

      function initializeGame() {
        if (gameInitialized) return;
        gameInitialized = true;
        bindControls();
        centerGameElements();
        requestAnimationFrame(update);
      }

      function centerGameElements() {
        leftPaddleY = gameBoard.clientHeight / 2 - leftPaddle.offsetHeight / 2;
        rightPaddleY = leftPaddleY;
        renderLeftPaddleY = leftPaddleY;
        renderRightPaddleY = rightPaddleY;
        ballX = gameBoard.clientWidth / 2 - ballSize / 2;
        ballY = gameBoard.clientHeight / 2 - ballSize / 2;
        renderBallX = ballX;
        renderBallY = ballY;
        updatePaddlePositions();
        updateBallPosition();
      }

      function bindControls() {
        if (controlsBound) return;
        controlsBound = true;
        document.addEventListener('keydown', (e) => {
          if (['ArrowUp', 'ArrowDown', ' '].includes(e.key)) {
            e.preventDefault();
          }
          keys[e.key] = true;
        });
        document.addEventListener('keyup', (e) => {
          keys[e.key] = false;
        });
        window.addEventListener('blur', () => {
          Object.keys(keys).forEach((key) => { keys[key] = false; });
        });
      }

      function update() {
        if (!gameStarted) return;
        handleLocalInput();
        runLocalSimulation();
        smoothOpponentPaddles();
        clampPaddles();
        updatePaddlePositions();

        if (!gameOver) {
          predictRemoteState();
          requestAnimationFrame(update);
        }
      }

      function handleLocalInput() {
        if (!playerRole) return;
        const upPressed = Boolean(keys.w || keys.W || keys.ArrowUp);
        const downPressed = Boolean(keys.s || keys.S || keys.ArrowDown);
        currentInput = {
          up: upPressed,
          down: downPressed,
        };

        const delayedFrame = simFrame + INPUT_DELAY_FRAMES;
        recordLocalInput(delayedFrame, currentInput);
      }

      function smoothOpponentPaddles() {
        if (playerRole !== 'left' && opponentTargets.left !== null) {
          renderLeftPaddleY = lerp(renderLeftPaddleY, opponentTargets.left, OPPONENT_LERP_FACTOR);
        } else {
          renderLeftPaddleY = leftPaddleY;
        }
        if (playerRole !== 'right' && opponentTargets.right !== null) {
          renderRightPaddleY = lerp(renderRightPaddleY, opponentTargets.right, OPPONENT_LERP_FACTOR);
        } else {
          renderRightPaddleY = rightPaddleY;
        }
      }

      function clampPaddles() {
        leftPaddleY = clampY(leftPaddleY);
        rightPaddleY = clampY(rightPaddleY);
        renderLeftPaddleY = clampY(renderLeftPaddleY);
        renderRightPaddleY = clampY(renderRightPaddleY);
      }

      function clampY(value) {
        const limit = gameBoard.clientHeight - leftPaddle.offsetHeight;
        return Math.max(0, Math.min(limit, value));
      }

      function lerp(start, end, alpha) {
        return start + (end - start) * alpha;
      }

      function averageSamples(list) {
        if (!list.length) return 0;
        return list.reduce((sum, value) => sum + value, 0) / list.length;
      }

      function updateDynamicSnapshotDelay() {
        const halfRtt = rttEstimate / 2;
        const jitterMargin = jitterEstimate * 2 + 20;
        dynamicSnapshotDelay = clamp(
          halfRtt + jitterMargin,
          80,
          400,
        );
      }

      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }

      function updatePaddlePositions() {
        leftPaddle.style.top = `${renderLeftPaddleY}px`;
        rightPaddle.style.top = `${renderRightPaddleY}px`;
      }

      function updateBallPosition() {
        ball.style.left = `${renderBallX}px`;
        ball.style.top = `${renderBallY}px`;
      }

      function hermiteInterpolate(p0, p1, v0, v1, t, durationSeconds) {
        const clampedT = Math.min(1, Math.max(0, t));
        const t2 = clampedT * clampedT;
        const t3 = t2 * clampedT;
        const m0 = v0 * durationSeconds;
        const m1 = v1 * durationSeconds;
        return (
          (2 * t3 - 3 * t2 + 1) * p0 +
          (t3 - 2 * t2 + clampedT) * m0 +
          (-2 * t3 + 3 * t2) * p1 +
          (t3 - t2) * m1
        );
      }


      function reflectBall(paddleY, paddleEl) {
        const paddleCenter = paddleY + paddleEl.offsetHeight / 2;
        const ballCenter = ballY + ballSize / 2;
        const offset = (ballCenter - paddleCenter) / (paddleEl.offsetHeight / 2);
        const deflectionFactor = 1.5;
        ballVelocityY = ballVelocityY * accelerationFactor + offset * deflectionFactor;
        const maxVerticalSpeed = 5;
        ballVelocityY = Math.max(-maxVerticalSpeed, Math.min(maxVerticalSpeed, ballVelocityY));
      }

      function showWinMessage(text) {
        if (document.getElementById('winMessage')) return;
        const winDiv = document.createElement('div');
        winDiv.id = 'winMessage';
        winDiv.textContent = text;
        document.body.appendChild(winDiv);
        setTimeout(() => {
          window.location.href = 'index.html';
        }, 5000);
      }

      function handleStateSnapshot(state) {
        if (!state || typeof state.timestamp !== 'number') return;
        if (latestSnapshot && state.timestamp <= latestSnapshot.timestamp) {
          return;
        }
        stateSnapshots.push(state);
        if (stateSnapshots.length > MAX_SNAPSHOTS) {
          stateSnapshots.shift();
        }
        latestSnapshot = state;

        if (typeof state.leftScore === 'number') {
          leftScore = state.leftScore;
          leftScoreEl.textContent = leftScore;
        }
        if (typeof state.rightScore === 'number') {
          rightScore = state.rightScore;
          rightScoreEl.textContent = rightScore;
        }
        if (typeof state.leftPaddleY === 'number') {
          const target = clampY(state.leftPaddleY);
          if (playerRole !== 'left') {
            leftPaddleY = target;
            opponentTargets.left = target;
          }
        }
        if (typeof state.rightPaddleY === 'number') {
          const target = clampY(state.rightPaddleY);
          if (playerRole !== 'right') {
            rightPaddleY = target;
            opponentTargets.right = target;
          }
        }
        if (typeof state.ballVX === 'number') {
          ballVelocityX = state.ballVX;
        }
        if (typeof state.ballVY === 'number') {
          ballVelocityY = state.ballVY;
        }
        recordRemoteInput('left', state.leftInputFrame || state.frame || 0, state.leftInput);
        recordRemoteInput('right', state.rightInputFrame || state.frame || 0, state.rightInput);
        reconcileAuthoritativeSnapshot(state);
        if (state.gameOver && !gameOver) {
          gameOver = true;
          matchActive = false;
          gameStarted = false;
          stopInputLoop();
          winnerLabel = state.winner || 'Player';
          showWinMessage(`${winnerLabel} wins!`);
        }
      }

      function reconcileAuthoritativeSnapshot(snapshot) {
        if (!snapshot || typeof snapshot.frame !== 'number') return;
        const targetFrame = snapshot.frame;
        const stored = stateHistory.get(targetFrame);
        const mismatch = !stored || statesDiffer(stored, snapshot);
        if (!mismatch) return;

        correctionsApplied += 1;
        const previousFrame = simFrame;
        applySnapshotToSim(snapshot);
        simFrame = targetFrame;
        simAccumulator = 0;
        lastUpdateTime = performance.now();

        while (historyOrder.length && historyOrder[historyOrder.length - 1] > targetFrame) {
          const removed = historyOrder.pop();
          stateHistory.delete(removed);
        }
        storeStateHistory(simState);

        if (previousFrame > targetFrame) {
          for (let frame = targetFrame + 1; frame <= previousFrame; frame += 1) {
            const leftInput = lookupInput('left', frame);
            const rightInput = lookupInput('right', frame);
            stepSimulation(simState, leftInput, rightInput);
            storeStateHistory(simState);
            simFrame = frame;
          }
        }

        trimInputBuffers(simFrame - MAX_ROLLBACK_FRAMES);
        syncViewState();
        runGuestSpeculativeCollisions();
        updateBallPosition();
      }

      function predictRemoteState() {
        // Local rollback simulation drives the render state.
      }

      function runGuestSpeculativeCollisions() {
        if (gameOver) return;

        const rightPaddleX = gameBoard.clientWidth - 20 - rightPaddle.offsetWidth;
        const rightTop = Math.max(0, renderRightPaddleY - paddleLagPadding);
        const rightBottom = Math.min(
          gameBoard.clientHeight,
          renderRightPaddleY + rightPaddle.offsetHeight + paddleLagPadding,
        );
        if (
          ballVelocityX > 0 &&
          renderBallX + ballSize >= rightPaddleX &&
          renderBallX <= rightPaddleX + rightPaddle.offsetWidth &&
          renderBallY + ballSize >= rightTop &&
          renderBallY <= rightBottom
        ) {
          ballY = renderBallY;
          reflectBall(renderRightPaddleY, rightPaddle);
          ballVelocityX = -Math.abs(ballVelocityX) * accelerationFactor;
          renderBallX = rightPaddleX - ballSize;
          ballX = renderBallX;
        }

        const leftCollisionX = 20 + leftPaddle.offsetWidth;
        const leftTop = Math.max(0, renderLeftPaddleY - paddleLagPadding);
        const leftBottom = Math.min(
          gameBoard.clientHeight,
          renderLeftPaddleY + leftPaddle.offsetHeight + paddleLagPadding,
        );
        if (
          ballVelocityX < 0 &&
          renderBallX <= leftCollisionX &&
          renderBallX + ballSize >= 20 &&
          renderBallY + ballSize >= leftTop &&
          renderBallY <= leftBottom
        ) {
          ballY = renderBallY;
          reflectBall(renderLeftPaddleY, leftPaddle);
          ballVelocityX = Math.abs(ballVelocityX) * accelerationFactor;
          renderBallX = leftCollisionX;
          ballX = renderBallX;
        }
      }

      connectSocket();
    })();
  </script>
</body>
</html>
